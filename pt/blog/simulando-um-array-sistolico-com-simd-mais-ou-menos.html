<!DOCTYPE html><html lang="pt" class="scroll-smooth"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Uma simula√ß√£o simples de um array sist√≥lico usando opera√ß√µes SIMD em Rust para acelerar multiplica√ß√£o de matrizes."><link rel="icon" type="image/x-icon" href="/favicon.ico"><meta name="theme-color" content="#222222" media="(prefers-color-scheme: dark)"><meta name="theme-color" content="#f5f5f5" media="(prefers-color-scheme: light)"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="apple-mobile-web-app-title" content="Nullenbox"><meta name="format-detection" content="telephone=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" href="/favicon.ico"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Merriweather+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet"><meta name="generator" content="Astro v5.16.6"><title>Nullenbox | Simulando Um Array Sist√≥lico Com SIMD (Mais ou Menos)</title><!-- Dark mode script - runs before page renders to prevent flash --><script>
      (function () {
        const theme = localStorage.getItem("theme");
        if (
          theme === "dark" ||
          (!theme && window.matchMedia("(prefers-color-scheme: dark)").matches)
        ) {
          document.documentElement.classList.add("dark");
        } else {
          document.documentElement.classList.remove("dark");
        }
      })();
    </script><link rel="stylesheet" href="/assets/blog.wRIwCgP3.css"></head> <body class="bg-surface text-on-surface min-h-screen font-inter transition-colors duration-200"> <header class="w-full py-4 border-b border-on-surface/10"> <div class="container mx-auto max-w-7xl px-8 flex items-center justify-between"> <a href="/pt/" class="flex items-center gap-3 text-2xl font-bold font-msans text-primary hover:text-primary/80 transition-colors no-underline"> <img src="/assets/nullenbox-logo.BnwysMj2.png" alt="Nullenbox Logo" class="w-8 h-8">
Nullenbox
</a> <nav class="flex items-center gap-6"> <ul class="flex items-center gap-6"> <li> <a href="/pt/" class="font-msans text-lg hover:text-primary transition-colors no-underline text-on-surface/80"> In√≠cio </a> </li><li> <a href="/pt/blog.html" class="font-msans text-lg hover:text-primary transition-colors no-underline text-on-surface/80"> Blog </a> </li><li> <a href="/pt/projects.html" class="font-msans text-lg hover:text-primary transition-colors no-underline text-on-surface/80"> Projetos </a> </li><li> <a href="/pt/reading-list.html" class="font-msans text-lg hover:text-primary transition-colors no-underline text-on-surface/80"> Leituras </a> </li> </ul> <!-- Language switcher --> <a href="/en/blog/simulando-um-array-sistolico-com-simd-mais-ou-menos.html" class="px-3 py-1.5 rounded-lg bg-on-surface/10 hover:bg-on-surface/20 transition-colors text-sm font-medium no-underline" aria-label="Mudar idioma" title="English"> üá∫üá∏ EN </a> <!-- Dark mode toggle --> <button id="theme-toggle" type="button" class="p-2 rounded-lg bg-on-surface/10 hover:bg-on-surface/20 transition-colors" aria-label="Alternar modo escuro"> <!-- Sun icon (shown in dark mode) --> <svg id="sun-icon" class="w-5 h-5 hidden dark:block text-yellow-400" fill="currentColor" viewBox="0 0 20 20"> <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path> </svg> <!-- Moon icon (shown in light mode) --> <svg id="moon-icon" class="w-5 h-5 block dark:hidden text-slate-700" fill="currentColor" viewBox="0 0 20 20"> <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path> </svg> </button> </nav> </div> </header> <script type="module">const a=document.getElementById("theme-toggle");function t(e){e?(document.documentElement.classList.add("dark"),localStorage.setItem("theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("theme","light"))}a?.addEventListener("click",()=>{const e=document.documentElement.classList.contains("dark");t(!e)});window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{localStorage.getItem("theme")||t(e.matches)});</script>  <main class="container mx-auto max-w-6xl px-8 py-12"> <article class="prose prose-lg"> <header class="mb-8 text-center"> <time datetime="2025-12-28T00:00:00.000Z" class="text-on-surface-muted text-sm"> 27 de dezembro de 2025 </time> <h1 class="mt-2">Simulando Um Array Sist√≥lico Com SIMD (Mais ou Menos)</h1> <p class="text-on-surface-muted text-lg">Uma simula√ß√£o simples de um array sist√≥lico usando opera√ß√µes SIMD em Rust para acelerar multiplica√ß√£o de matrizes.</p> <div class="flex flex-wrap justify-center gap-2 mt-4"> <span class="px-3 py-1 text-sm rounded-full bg-primary/10 text-primary">
#TPU </span><span class="px-3 py-1 text-sm rounded-full bg-primary/10 text-primary">
#rust </span><span class="px-3 py-1 text-sm rounded-full bg-primary/10 text-primary">
#array sist√≥lico </span><span class="px-3 py-1 text-sm rounded-full bg-primary/10 text-primary">
#intelig√™ncia artificial </span> </div> </header> <h1 id="simulando-um-array-sist√≥lico-com-simd-mais-ou-menos">Simulando Um Array Sist√≥lico Com SIMD (Mais ou Menos)</h1>
<p>Decidi tentar entender como uma TPU funciona. Como n√£o tenho nenhuma experi√™ncia com hardware, decidi tentar simular um array sist√≥lico usando opera√ß√µes SIMD. O resultado n√£o √© uma simula√ß√£o ‚Äúreal‚Äù, porque n√£o tentei simular o hardware em si, mas a ideia por tr√°s dele e o fluxo de dados (parcialmente).</p>
<p>Eu queria tentar fazer minha CPU realizar multiplica√ß√µes de matrizes mais r√°pido usando uma estrat√©gia que vagamente se assemelhava a como um array sist√≥lico funciona.</p>
<h2 id="o-que-√©-um-array-sist√≥lico">O que √© um array sist√≥lico?</h2>
<p>Simplificando, √© um dispositivo que organiza v√°rias unidades de processamento de dados de forma homog√™nea para realizar uma opera√ß√£o predefinida. O que vamos focar √© multiplica√ß√£o de matrizes, mas poderia fazer outras coisas como correla√ß√£o, convolu√ß√£o, ou at√© ordena√ß√£o de dados.</p>
<p>Um array sist√≥lico √© o bloco de constru√ß√£o prim√°rio de uma TPU (unidade de processamento de tensores), que hoje em dia se tornou muito mais interessante para mim por causa da intelig√™ncia artificial. IA pode ultimamente ser reduzida a uma tonelada de multiplica√ß√µes de matrizes, e a CPU √© terr√≠vel em realizar multiplica√ß√£o de matrizes.</p>
<p>No caso de opera√ß√µes de multiplica√ß√£o de matrizes, cada PE recebe dados de ‚Äúcima‚Äù e da ‚Äúesquerda‚Äù, ent√£o realiza uma multiplica√ß√£o com os dois valores, armazena o resultado em um registrador acumulador, e passa os valores adiante. Os valores continuam em cascata para baixo e para a direita at√© que o √∫ltimo PE (na borda inferior direita) realize o √∫ltimo c√°lculo.</p>
<p>Aqui est√° um diagrama que demonstra o fluxo de dados
<img src="https://www.researchgate.net/publication/350817492/figure/fig1/AS:1048198110015488@1626921312207/Systolic-array-matrix-multiplication-block.png" alt="ilustra√ß√£o"></p>
<p>Para compara√ß√£o, um array sist√≥lico 256x256 √© capaz de realizar at√© 65.536 opera√ß√µes por tick de clock, enquanto uma CPU (assumindo execu√ß√£o escalar single-core) pode fazer 1 opera√ß√£o por tick de clock. Esta compara√ß√£o n√£o √© 100% justa, mas serve para ilustrar a discrep√¢ncia nas capacidades de opera√ß√£o paralela.</p>
<p>Agora, quando esse tipo de opera√ß√£o precisa ser feita, uma GPU √© usada (da√≠ as a√ß√µes da Nvidia üëÄ), mas imagine um cen√°rio onde voc√™ est√° jogando um jogo e um dos inimigos no jogo √© controlado por um modelo de IA mais sofisticado. A GPU pode j√° estar fazendo muito trabalho para processar os gr√°ficos, a CPU est√° ocupada servindo dados para a GPU, rodando o SO, e, como j√° sabemos, CPUs n√£o s√£o conhecidas por serem √≥timas com multiplica√ß√£o de matrizes de qualquer forma. Esse √© o cen√°rio onde uma TPU √© √∫til e √© uma das principais raz√µes pelas quais acho que hardware de edge computing se tornar√° mais relevante no futuro.</p>
<h2 id="o-que-√©-simd">O que √© SIMD</h2>
<p>CPUs modernas geralmente cont√™m instru√ß√µes especiais comumente chamadas SIMD que podem realizar uma opera√ß√£o com m√∫ltiplos valores ao mesmo tempo (no mesmo core), e √© mais f√°cil entend√™-las se voc√™ tentar pensar em ‚Äúmodo Assembly‚Äù. Um exemplo usando pseudo-c√≥digo poderia ser assim (n√£o sei Assembly):</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#E1E4E8">A </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">8</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">B </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">8</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">13</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">21</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">34</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">; </span><span style="color:#79B8FF">8</span><span style="color:#E1E4E8">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">C[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C[</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A[</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B[</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C[</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A[</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B[</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C[</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A[</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B[</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C[</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A[</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B[</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C[</span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A[</span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B[</span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C[</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A[</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B[</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">]</span></span></code></pre>
<p>Cada opera√ß√£o de multiplica√ß√£o √© realizada uma ap√≥s a outra.</p>
<p>Usando SIMD, um pseudo-c√≥digo que pode ilustrar o que acontece poderia ser assim:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#E1E4E8">A </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">8</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">B </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">8</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">13</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">21</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">34</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">C </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> A </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> B</span></span></code></pre>
<p>Infelizmente, n√£o consigo pensar em uma forma melhor de representar isso, mas o ponto principal √© que no primeiro exemplo, a CPU vai carregar os valores de A e B um por um em seus registradores, realizar a multiplica√ß√£o, e armazenar o valor de volta. Enquanto no segundo caso (usando SIMD), todos os valores de A s√£o carregados de uma vez em um ‚Äúregistrador muito grande‚Äù, o mesmo para B, a multiplica√ß√£o √© aplicada elemento a elemento, e o resultado √© armazenado de volta na mem√≥ria.</p>
<p>Isso come√ßa a fazer diferen√ßa quando come√ßamos a fazer multiplica√ß√£o de matrizes. Por exemplo, multiplicar uma matriz 256x256 por outra matriz 256x256 (ignorando poss√≠veis otimiza√ß√µes) exigiria quase 17 milh√µes de multiplica√ß√µes individuais sozinhas. Mas tamb√©m h√° adi√ß√µes, carregamento de valores da mem√≥ria, e outras opera√ß√µes envolvidas. Pode ficar bem lento (e vai).</p>
<p>Ao longo deste artigo, estarei usando o termo SIMD (que √© mais gen√©rico) para me referir ao conjunto de instru√ß√µes dispon√≠vel na CPU do meu PC, que √© AVX2. Ele pode carregar at√© 256 bits por lane, o que √© equivalente a 8 n√∫meros de ponto flutuante de 32 bits. Os exemplos de c√≥digo mostrados provavelmente n√£o funcionar√£o com outros tipos de conjuntos de instru√ß√µes SIMD.</p>
<h2 id="implementando">Implementando</h2>
<p>Para a implementa√ß√£o decidi usar Rust.</p>
<p>O primeiro passo √© implementar uma multiplica√ß√£o de matrizes tradicional usando a CPU de forma escalar com execu√ß√£o single-core para ter algo para comparar. Mas antes disso precisamos de uma forma de criar matrizes, decidi criar uma fun√ß√£o que recebe n√∫mero de colunas e n√∫mero de linhas como entrada e gera um vetor de vetores com valores aleat√≥rios usando o crate <code>rand</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> rand</span><span style="color:#F97583">::</span><span style="color:#B392F0">Rng</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> gen_rand_matrix</span><span style="color:#E1E4E8">(rows</span><span style="color:#F97583">:</span><span style="color:#B392F0"> usize</span><span style="color:#E1E4E8">, cols</span><span style="color:#F97583">:</span><span style="color:#B392F0"> usize</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>> {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> rng </span><span style="color:#F97583">=</span><span style="color:#B392F0"> rand</span><span style="color:#F97583">::</span><span style="color:#B392F0">rng</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> matrix </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">0.0</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">; cols]; rows];</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">rows {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">cols {</span></span>
<span class="line"><span style="color:#E1E4E8">            matrix[i][j] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> rng</span><span style="color:#F97583">.</span><span style="color:#B392F0">random_range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">..</span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    matrix</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Agora a fun√ß√£o que multiplica duas matrizes e a fun√ß√£o main para executar e coletar o tempo de execu√ß√£o</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">time</span><span style="color:#F97583">::</span><span style="color:#B392F0">Instant</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> rand</span><span style="color:#F97583">::</span><span style="color:#B392F0">Rng</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> gen_rand_matrix</span><span style="color:#E1E4E8">(rows</span><span style="color:#F97583">:</span><span style="color:#B392F0"> usize</span><span style="color:#E1E4E8">, cols</span><span style="color:#F97583">:</span><span style="color:#B392F0"> usize</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>> {</span><span style="color:#F97583">...</span><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> scalar_matrix_mult</span><span style="color:#E1E4E8">(a</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>], b</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>]) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>> {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> rows </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> a</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> inner </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> a[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> cols </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> b[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    assert_eq!</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">        inner,</span></span>
<span class="line"><span style="color:#E1E4E8">        b</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">(),</span></span>
<span class="line"><span style="color:#9ECBFF">        "Matrix dimensions do not match for multiplication"</span></span>
<span class="line"><span style="color:#E1E4E8">    );</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">0.0</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">; cols]; rows];</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">rows {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">cols {</span></span>
<span class="line"><span style="color:#F97583">            let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> sum </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.0</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> k </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">inner {</span></span>
<span class="line"><span style="color:#E1E4E8">                sum </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> a[i][k] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> b[k][j];</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">            result[i][j] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> sum;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    result</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#B392F0"> gen_rand_matrix</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> b </span><span style="color:#F97583">=</span><span style="color:#B392F0"> gen_rand_matrix</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> start_classical </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Instant</span><span style="color:#F97583">::</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> _ </span><span style="color:#F97583">=</span><span style="color:#B392F0"> scalar_matrix_mult</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">a, </span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">b);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> duration_classical </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> start_classical</span><span style="color:#F97583">.</span><span style="color:#B392F0">elapsed</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">as_millis</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"multiplica√ß√£o escalar de matrizes: {duration_classical} ms"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Na minha m√°quina leva cerca de 350ms para multiplicar essas duas matrizes quadradas.</p>
<p>Agora, precisamos implementar isso para funcionar com SIMD, para fazer isso precisamos usar o build nightly do cargo e usar a feature <code>portable_simd</code></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#E1E4E8">#![feature(portable_simd)]</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">simd</span><span style="color:#F97583">::</span><span style="color:#B392F0">num</span><span style="color:#F97583">::</span><span style="color:#B392F0">SimdFloat</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">simd</span><span style="color:#F97583">::</span><span style="color:#B392F0">Simd</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">time</span><span style="color:#F97583">::</span><span style="color:#B392F0">Instant</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> rand</span><span style="color:#F97583">::</span><span style="color:#B392F0">Rng</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>Tamb√©m defini uma constante que representa a quantidade de valores float32 que cabem em cada lane SIMD
<code>const N: usize = 8;</code> e um tipo para representar uma lane <code>type Lane = Simd&#x3C;f32, 8>;</code></p>
<p>Mas antes de implementar a fun√ß√£o para a multiplica√ß√£o de matrizes precisamos considerar o ‚Äúlayout‚Äù dos dados, j√° que estamos tentando simular um array sist√≥lico, faz sentido organizar os dados de cada matriz para serem alimentados para a fun√ß√£o de forma similar ao que aconteceria em um array sist√≥lico, com colunas da primeira matriz vindo da ‚Äúesquerda‚Äù e linhas da segunda matriz vindo de ‚Äúcima‚Äù.
As fun√ß√µes <code>pack_rows</code> e <code>pack_cols</code> recebem uma matriz (vetor de vetores) como entrada e retornam a mesma matriz mas organizada em Lanes (vetor de vetor de lanes). N√£o muito eficiente em mem√≥ria, mas direto.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> pack_rows</span><span style="color:#E1E4E8">(a</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>]) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Lane</span><span style="color:#E1E4E8">>> {</span></span>
<span class="line"><span style="color:#E1E4E8">    a</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">map</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">row</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">            row</span><span style="color:#F97583">.</span><span style="color:#B392F0">chunks</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">N</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">                .</span><span style="color:#B392F0">map</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">chunk</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">                    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> buf </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">N</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#E1E4E8">                    buf[</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">chunk</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">()]</span><span style="color:#F97583">.</span><span style="color:#B392F0">copy_from_slice</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#B392F0">                    Lane</span><span style="color:#F97583">::</span><span style="color:#B392F0">from_array</span><span style="color:#E1E4E8">(buf)</span></span>
<span class="line"><span style="color:#E1E4E8">                })</span></span>
<span class="line"><span style="color:#F97583">                .</span><span style="color:#B392F0">collect</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">        })</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">collect</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> pack_cols</span><span style="color:#E1E4E8">(b</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>]) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Lane</span><span style="color:#E1E4E8">>> {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> rows </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> b</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> cols </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> b[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    (</span><span style="color:#79B8FF">0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">cols)</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">map</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">j</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">            let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> col </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Vec</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> chunk_start </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">rows)</span><span style="color:#F97583">.</span><span style="color:#B392F0">step_by</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">N</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">                let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> buf </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">0.0</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">N</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">                for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#B392F0">N</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">                    let</span><span style="color:#E1E4E8"> idx </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> chunk_start </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#F97583">                    if</span><span style="color:#E1E4E8"> idx </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> rows {</span></span>
<span class="line"><span style="color:#E1E4E8">                        buf[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> b[idx][j];</span></span>
<span class="line"><span style="color:#E1E4E8">                    }</span></span>
<span class="line"><span style="color:#E1E4E8">                }</span></span>
<span class="line"><span style="color:#E1E4E8">                col</span><span style="color:#F97583">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">Lane</span><span style="color:#F97583">::</span><span style="color:#B392F0">from_array</span><span style="color:#E1E4E8">(buf));</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">            col</span></span>
<span class="line"><span style="color:#E1E4E8">        })</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">collect</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Com isso em vigor, agora podemos criar a fun√ß√£o de multiplica√ß√£o de matrizes que recebe uma matriz ‚Äúempacotada‚Äù e usa SIMD para realizar as opera√ß√µes</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> simd_matrix_mult</span><span style="color:#E1E4E8">(a_rows</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Lane</span><span style="color:#E1E4E8">>], b_cols</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Lane</span><span style="color:#E1E4E8">>]) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>> {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">0.0</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">; b_cols</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">()]; a_rows</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">()];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">a_rows</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">b_cols</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">            let</span><span style="color:#E1E4E8"> a_vecs </span><span style="color:#F97583">=</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">a_rows[i];</span></span>
<span class="line"><span style="color:#F97583">            let</span><span style="color:#E1E4E8"> b_vecs </span><span style="color:#F97583">=</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">b_cols[j];</span></span>
<span class="line"><span style="color:#F97583">            let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> acc </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.0</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> idx </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">a_vecs</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">                acc </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> (a_vecs[idx] </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> b_vecs[idx])</span><span style="color:#F97583">.</span><span style="color:#B392F0">reduce_sum</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">            result[i][j] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> acc;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    result</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Tamb√©m decidi criar uma fun√ß√£o que compara duas matrizes para ver se s√£o equivalentes, considerando um valor de toler√¢ncia porque estamos lidando com aritm√©tica de ponto flutuante</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> matrices_equivalent</span><span style="color:#E1E4E8">(a</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>], b</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>], tol</span><span style="color:#F97583">:</span><span style="color:#B392F0"> f32</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> bool</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> a</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> b</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> a[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> b[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">a</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">a[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (a[i][j] </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> b[i][j])</span><span style="color:#F97583">.</span><span style="color:#B392F0">abs</span><span style="color:#E1E4E8">() > tol {</span></span>
<span class="line"><span style="color:#B392F0">                println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Diferen√ßa em ({}, {}): {} vs {}"</span><span style="color:#E1E4E8">, i, j, a[i][j], b[i][j]);</span></span>
<span class="line"><span style="color:#F97583">                return</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">    true</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Tamb√©m alterei a fun√ß√£o main para executar ambas as fun√ß√µes, cronometrar e comparar os resultados</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#B392F0"> gen_rand_matrix</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> b </span><span style="color:#F97583">=</span><span style="color:#B392F0"> gen_rand_matrix</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> a_rows </span><span style="color:#F97583">=</span><span style="color:#B392F0"> pack_rows</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">a);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> b_cols </span><span style="color:#F97583">=</span><span style="color:#B392F0"> pack_cols</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">b);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> start_classical </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Instant</span><span style="color:#F97583">::</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> scalar_result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> scalar_matrix_mult</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">a, </span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">b);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> duration_classical </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> start_classical</span><span style="color:#F97583">.</span><span style="color:#B392F0">elapsed</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">as_millis</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"multiplica√ß√£o escalar de matrizes: {duration_classical} ms"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> start_simd </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Instant</span><span style="color:#F97583">::</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> simd_result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> simd_matrix_mult</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">a_rows, </span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">b_cols);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> duration_simd </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> start_simd</span><span style="color:#F97583">.</span><span style="color:#B392F0">elapsed</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">as_millis</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"multiplica√ß√£o de matrizes SIMD: {duration_simd} ms"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> matrices_equivalent</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">scalar_result, </span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">simd_result, </span><span style="color:#79B8FF">0.01</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Resultados s√£o equivalentes."</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Resultados diferem significativamente."</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<blockquote>
<p>Como reorganizar os dados leva tempo e isso n√£o aconteceria em um hardware real, decidi n√£o considerar o tempo que leva para empacotar a matriz ao comparar o tempo de execu√ß√£o, mas mostrarei separadamente.</p>
</blockquote>
<p>Aqui est√° a sa√≠da</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="txt"><code><span class="line"><span>Empacotamento levou: 2 ms</span></span>
<span class="line"><span>multiplica√ß√£o escalar de matrizes: 354 ms</span></span>
<span class="line"><span>multiplica√ß√£o de matrizes SIMD: 74 ms</span></span>
<span class="line"><span>Resultados s√£o equivalentes.</span></span></code></pre>
<p>Os valores absolutos n√£o significam muito, porque cada hardware vai produzir tempos de execu√ß√£o diferentes, mas a diferen√ßa entre os valores √© substancial. Isso fica mais evidente se aumentarmos o tamanho da matriz, aqui est√° uma compara√ß√£o indo de 256 at√© 2048.</p>



































<table><thead><tr><th>Tamanho da Matriz</th><th>Escalar</th><th>SIMD</th><th>Diff</th></tr></thead><tbody><tr><td>256x256</td><td>~350ms</td><td>~75ms</td><td>~4.5x</td></tr><tr><td>512x512</td><td>~3s</td><td>~0.6s</td><td>~5x</td></tr><tr><td>1024x1024</td><td>~27s</td><td>~4.5s</td><td>~6x</td></tr><tr><td>2048x2048</td><td>~245s</td><td>~37s</td><td>~6.5x</td></tr></tbody></table>
<p>Podemos observar um aumento no desempenho comparativo que √© quase linear, e claro que isso eventualmente vai saturar por causa de gargalo de mem√≥ria, mas mesmo assim, acho isso incr√≠vel.</p>
<h2 id="usando-m√∫ltiplos-cores">Usando m√∫ltiplos cores</h2>
<p>Como j√° fizemos tudo isso, por que n√£o dar um passo adiante e usar todos os cores dispon√≠veis, cada um usando SIMD para ver quais resultados obtemos?</p>
<p>Para fazer isso decidi usar o crate <code>rayon</code> e a ideia √© simples, cada core de CPU (no meu caso 8 no total) vai usar SIMD para realizar m√∫ltiplas opera√ß√µes em paralelo e a matriz ser√° dividida em chunks maiores de 8 para que cada chunk maior possa ser processado por um core individual. Como cada lane SIMD pode trabalhar com at√© 8 valores float32 de uma vez, cada chunk maior ser√° de tamanho 64 (oito ao quadrado).</p>
<p>Aqui est√° a fun√ß√£o:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> parallel_simd_matrix_mult</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">    a_rows</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Lane</span><span style="color:#E1E4E8">>],</span></span>
<span class="line"><span style="color:#E1E4E8">    b_cols</span><span style="color:#F97583">:</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Lane</span><span style="color:#E1E4E8">>],</span></span>
<span class="line"><span style="color:#E1E4E8">) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">Vec</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">>> {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> m </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> a_rows</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> n </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> b_cols</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> tile_size </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 64</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">0.0</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">; n]; m];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    result</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">par_chunks_mut</span><span style="color:#E1E4E8">(tile_size)</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">enumerate</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">for_each</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">(tile_row_idx, tile_chunk)</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">            let</span><span style="color:#E1E4E8"> i0 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tile_row_idx </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> tile_size;</span></span>
<span class="line"><span style="color:#F97583">            let</span><span style="color:#E1E4E8"> i_max </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (i0 </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> tile_chunk</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">())</span><span style="color:#F97583">.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(m);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> (ii, row) </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> tile_chunk</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter_mut</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">enumerate</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">                let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i0 </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> ii;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">                for</span><span style="color:#E1E4E8"> j0 </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">n)</span><span style="color:#F97583">.</span><span style="color:#B392F0">step_by</span><span style="color:#E1E4E8">(tile_size) {</span></span>
<span class="line"><span style="color:#F97583">                    let</span><span style="color:#E1E4E8"> j_max </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (j0 </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> tile_size)</span><span style="color:#F97583">.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(n);</span></span>
<span class="line"><span style="color:#F97583">                    for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> j0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">j_max {</span></span>
<span class="line"><span style="color:#F97583">                        let</span><span style="color:#E1E4E8"> a_vecs </span><span style="color:#F97583">=</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">a_rows[i];</span></span>
<span class="line"><span style="color:#F97583">                        let</span><span style="color:#E1E4E8"> b_vecs </span><span style="color:#F97583">=</span><span style="color:#F97583"> &#x26;</span><span style="color:#E1E4E8">b_cols[j];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">                        let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> acc </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.0</span><span style="color:#B392F0">f32</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">                        for</span><span style="color:#E1E4E8"> (a_lane, b_lane) </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> a_vecs</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">zip</span><span style="color:#E1E4E8">(b_vecs</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#E1E4E8">                            acc </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">a_lane </span><span style="color:#F97583">*</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">b_lane)</span><span style="color:#F97583">.</span><span style="color:#B392F0">reduce_sum</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">                        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">                        row[j] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> acc;</span></span>
<span class="line"><span style="color:#E1E4E8">                    }</span></span>
<span class="line"><span style="color:#E1E4E8">                }</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    result</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Para ser 100% honesto, essa √© a parte onde eu me perdi e apenas usei o chatGPT para chegar na fun√ß√£o final, nesse ponto eu estava apenas tentando obter n√∫meros ainda mais impressionantes e n√£o estava me importando tanto com como eu cheguei l√°.</p>
<p>De qualquer forma, aqui est√° a compara√ß√£o</p>









































<table><thead><tr><th>Tamanho da Matriz</th><th>SIMD</th><th>SIMD + Rayon</th><th>Diff</th></tr></thead><tbody><tr><td>256x256</td><td>~70ms</td><td>~10ms</td><td>~7x</td></tr><tr><td>512x512</td><td>~600ms</td><td>~45ms</td><td>~13x</td></tr><tr><td>1024x1024</td><td>~4.65s</td><td>~0.25s</td><td>~18.5x</td></tr><tr><td>2048x2048</td><td>~37.5s</td><td>~1.75s</td><td>~21x</td></tr><tr><td>4096x4096</td><td>~285s</td><td>~13s</td><td>~22x</td></tr></tbody></table>
<p>N√£o comparei todos os tr√™s de uma vez porque fazer a √∫ltima multiplica√ß√£o levaria muito tempo rodando em CPU escalar</p>
<h2 id="conclus√£o">Conclus√£o</h2>
<p>Para mim tudo isso foi uma √≥tima experi√™ncia de aprendizado, n√£o acho que nenhuma dessas coisas seja ‚Äú√∫til‚Äù no contexto de desenvolvimento de software profissional, mas me fez apreciar mais o trabalho que entra em resolver um ‚Äúproblema simples‚Äù como fazer multiplica√ß√£o de matrizes ir mais r√°pido. Levei muito tempo para entender como as coisas estavam funcionando nesta ‚Äúsimula√ß√£o‚Äù de software, imagine o que entra em criar o hardware real.</p>
<p>No final estou animado para ver quais outras tecnologias incr√≠veis ser√£o criadas, aprimoradas ou reutilizadas para suportar o uso amplo de modelos de IA.</p> </article> </main> <footer class="w-full py-12"> <div class="container mx-auto max-w-7xl px-8 flex flex-col md:flex-row items-center justify-between"> <nav class="flex items-center sm:flex"> <ul class="flex items-center gap-4"> <li class="font-msans text-lg"> <a href="/pt/blog.html">Blog</a> </li> <li class="font-msans text-lg"> <a href="/pt/reading-list.html">Leituras</a> </li> <li class="font-msans text-lg"> <a href="/pt/projects.html">Projetos</a> </li> </ul> </nav> </div> </footer>  </body></html>